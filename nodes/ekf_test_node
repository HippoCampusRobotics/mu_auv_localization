#!/usr/bin/env python

import numpy as np
from pyquaternion import Quaternion
import rospy
import rospkg
import tf
from hippocampus_common.node import Node
from mu_auv_localization.ekf_test_class import ExtendedKalmanFilter
from mu_auv_localization.meas_model_class import MeasurementModelDistances
from mu_auv_localization.process_model_class import ProcessModel

from geometry_msgs.msg import PoseStamped, TwistStamped
from apriltag_ros.msg import AprilTagDetectionArray
from sensor_msgs.msg import Imu
from numpy import genfromtxt
import threading

rospack = rospkg.RosPack()
tags = None
cam_reversed = False
meas_model_type = None
process_model_type = None


class EKFNode(Node):
    def __init__(self):
        super(EKFNode, self).__init__("ekf_node")

        self.lock = threading.Lock()
        self.t_last_prediction = rospy.get_time()
        # self.tf_buffer = tf2_ros.Buffer()
        # self.tf_listener = tf2_ros.TransformListener(self.tf_buffer)
        # self.tf_buffer.lookup_transform(target_frame="map_ned",
        #                                 source_frame="map",
        #                                 time=rospy.Time(0),
        #                                 timeout=rospy.Duration(10))

        if meas_model_type == "dist":
            if process_model_type == "standard":
                dim_state, dim_meas, W, V, P0, x0 = self._load_ekf_params_dist()

                process_model = ProcessModel(dim_state, dim_meas, V)
                measurement_model = MeasurementModelDistances(dim_state, dim_meas, W)
                self.ekf = ExtendedKalmanFilter(dim_state, dim_meas, measurement_model, process_model, x0, P0)
        else:
            rospy.logerr("[{}] Choose valid measurement model.".format(rospy.get_name()))
            exit(-1)

        self.vision_pose_pub = rospy.Publisher("mavros/vision_pose/pose",
                                               PoseStamped,
                                               queue_size=1)

        self.estimated_pose_pub = rospy.Publisher('estimated_pose',
                                                  PoseStamped,
                                                  queue_size=1)
        self.twist_pub = rospy.Publisher('estimated_twist',
                                         TwistStamped,
                                         queue_size=1)

        rospy.Subscriber("pose_px4",
                         PoseStamped,
                         self.px4_callback,
                         queue_size=1)

        rospy.Subscriber("mavros/imu/data",
                         Imu,
                         self.imu_callback,
                         queue_size=1)

        rospy.Subscriber("tag_detections",
                         AprilTagDetectionArray,
                         self.apriltag_callback,
                         queue_size=1)

    def apriltag_callback(self, tag_array_msg):
        num_tags = len(tag_array_msg.detections)

        # if tags are detected
        if num_tags:

            if meas_model_type == "dist":
                # measurement for each tag consists of distance and yaw angle
                # -> dim_meas = 2
                measurements = np.zeros((num_tags * self.ekf.dim_meas, 1))
                detected_tags = np.zeros((num_tags, tags.shape[1]))

                for i, tag in enumerate(tag_array_msg.detections):

                    tag_id = int(tag.id[0])

                    # add this tag's information to list of detected tags
                    index = np.where(tags[:, 0] == tag_id)
                    detected_tags[i, 1:4] = tags[index, 1:4]

                    # TODO "calibration"
                    if cam_reversed:
                        tag_distance_cam = np.array(
                            ([
                                -tag.pose.pose.pose.position.x * 1.05,
                                -tag.pose.pose.pose.position.y * 1.1,
                                tag.pose.pose.pose.position.z
                            ])
                        )  # Achtung hier ist die 0.1 wegen der kamera position hinzugefuegt
                    else:
                        tag_distance_cam = np.array(
                            ([
                                tag.pose.pose.pose.position.x * 1.05,
                                tag.pose.pose.pose.position.y * 1.1,
                                tag.pose.pose.pose.position.z
                            ])
                        )  # Achtung hier ist die 0.1 wegen der kamera position hinzugefuegt

                    tmpquat = Quaternion(w=tag.pose.pose.pose.orientation.w,
                                         x=tag.pose.pose.pose.orientation.x,
                                         y=tag.pose.pose.pose.orientation.y,
                                         z=tag.pose.pose.pose.orientation.z)

                    yaw_tag_cam = tmpquat.inverse.yaw_pitch_roll[0]

                    if cam_reversed:
                        yaw_tag_cam = yaw_tag_cam + np.pi

                    # measurement 1: distance tag - camera
                    measurements[self.dim_meas * i, 0] = np.linalg.norm(tag_distance_cam)
                    # measurement 2: yaw angle tag - camera (todo check direction)
                    measurements[self.self.dim_meas * i + 1, 0] = yaw_tag_cam

            elif meas_model_type == "full_pose":

                # not complete yet

                # measurement for each tag consists of full pose measurement camera-tag
                # -> dim_meas = 7
                measurements = np.zeros((num_tags * self.ekf.dim_meas, 1))
                detected_tags = np.zeros((num_tags, tags.shape[1]))

                for i, tag in enumerate(tag_array_msg.detections):

                    tag_id = int(tag.id[0])

                    # add this tag's information to list of detected tags
                    index = np.where(tags[:, 0] == tag_id)
                    detected_tags[i, 1:4] = tags[index, 1:4]

                    # TODO check "calibration", rewrite this
                    if cam_reversed:
                        tag_distance_cam = np.array(
                            ([
                                -tag.pose.pose.pose.position.x * 1.05,
                                -tag.pose.pose.pose.position.y * 1.1,
                                tag.pose.pose.pose.position.z
                            ])
                        )  # Achtung hier ist die 0.1 wegen der kamera position hinzugefuegt
                    else:
                        tag_distance_cam = np.array(
                            ([
                                tag.pose.pose.pose.position.x * 1.05,
                                tag.pose.pose.pose.position.y * 1.1,
                                tag.pose.pose.pose.position.z
                            ])
                        )  # Achtung hier ist die 0.1 wegen der kamera position hinzugefuegt

                    orientation = Quaternion(w=tag.pose.pose.pose.orientation.w,
                                             x=tag.pose.pose.pose.orientation.x,
                                             y=tag.pose.pose.pose.orientation.y,
                                             z=tag.pose.pose.pose.orientation.z)

                    if cam_reversed:
                        # todo
                        rospy.logerr("[{}] Orientation for reversed camera not defined yet.".format(rospy.get_name()))

                    # measurement: full pose, orientation not transformed yet!
                    measurements[(self.dim_meas * i):(self.dim_meas*(i + 1) - 1), 0] \
                        = np.array([tag_distance_cam[0], tag_distance_cam[1], tag_distance_cam[2], orientation[3],
                                    tag.pose.pose.pose.orientation.w, tag.pose.pose.pose.orientation.x,
                                    tag.pose.pose.pose.orientation.y, tag.pose.pose.pose.orientation.z]).reshape((-1, 1))

            # do prediction + update step of ekf
            with self.lock:
                now = rospy.get_time()
                self.ekf.predict(now - self.t_last_prediction)
                self.t_last_prediction = now
                self.ekf.update(measurements, detected_tags)

            self._publish_pose_estimation()

    def px4_callback(self, pose_msg):

        with self.lock:
            now = rospy.get_time()
            self.ekf.predict(now - self.t_last_prediction)
            self.t_last_prediction = now
            self.ekf.update_orientation()

    def imu_callback(self, imu_msg):

        with self.lock:
            now = rospy.get_time()
            self.ekf.predict(now - self.t_last_prediction)
            self.t_last_prediction = now
            self.ekf.update_angular_vel()

    def _publish_pose_estimation(self):
        estimation = self.ekf._x_est
        position = estimation[:3]
        orientation = estimation[3:7]
        pose = PoseStamped()
        pose.pose.position.x = position[0]
        pose.pose.position.y = position[1]
        pose.pose.position.z = position[2]
        pose.pose.orientation.x = orientation[0]
        pose.pose.orientation.y = orientation[1]
        pose.pose.orientation.z = orientation[2]
        pose.pose.orientation.w = orientation[3]
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = "map"
        self.vision_pose_pub.publish(pose)

    def _load_ekf_params_dist(self):

        try:
            dim_meas = rospy.get_param('ekf/dim_meas')
            dim_state = rospy.get_param('ekf/dim_state')

            # initial state
            x = rospy.get_param('ekf/x0/x')
            y = rospy.get_param('ekf/x0/y')
            z = rospy.get_param('ekf/x0/z')
            roll = rospy.get_param('ekf/x0/roll')
            pitch = rospy.get_param('ekf/x0/pitch')
            yaw = rospy.get_param('ekf/x0/yaw')
            dx = rospy.get_param('ekf/x0/dx')
            dy = rospy.get_param('ekf/x0/dy')
            dz = rospy.get_param('ekf/x0/dz')
            droll = rospy.get_param('ekf/x0/droll')
            dpitch = rospy.get_param('ekf/x0/dpitch')
            dyaw = rospy.get_param('ekf/x0/dyaw')

            x0 = np.array([x, y, z, roll, pitch, yaw, dx, dy, dz, droll, dpitch, dyaw]).reshape((-1, 1))

            # state covariance P0 params
            sig_x = rospy.get_param('ekf/p_mat/sig_x')
            sig_y = rospy.get_param('ekf/p_mat/sig_y')
            sig_z = rospy.get_param('ekf/p_mat/sig_z')
            sig_roll = rospy.get_param('ekf/p_mat/sig_roll')
            sig_pitch = rospy.get_param('ekf/p_mat/sig_pitch')
            sig_yaw = rospy.get_param('ekf/p_mat/sig_yaw')
            sig_dx = rospy.get_param('ekf/p_mat/sig_dx')
            sig_dy = rospy.get_param('ekf/p_mat/sig_dy')
            sig_dz = rospy.get_param('ekf/p_mat/sig_dz')
            sig_droll = rospy.get_param('ekf/p_mat/sig_droll')
            sig_dpitch = rospy.get_param('ekf/p_mat/sig_dpitch')
            sig_dyaw = rospy.get_param('ekf/p_mat/sig_dyaw')

            P0 = np.array(np.diag([sig_x ** 2, sig_y ** 2, sig_z ** 2, sig_roll ** 2, sig_pitch ** 2, sig_yaw ** 2,
                                   sig_dx ** 2, sig_dy ** 2, sig_dz ** 2, sig_droll ** 2, sig_dpitch ** 2, sig_dyaw ** 2]))

            # process noise
            sig_v_x = rospy.get_param('ekf/v_mat/sig_v_x')
            sig_v_y = rospy.get_param('ekf/v_mat/sig_v_y')
            sig_v_z = rospy.get_param('ekf/v_mat/sig_v_z')
            sig_v_roll = rospy.get_param('ekf/v_mat/sig_v_roll')
            sig_v_pitch = rospy.get_param('ekf/v_mat/sig_v_pitch')
            sig_v_yaw = rospy.get_param('ekf/v_mat/sig_v_yaw')
            sig_v_dx = rospy.get_param('ekf/v_mat/sig_v_dx')
            sig_v_dy = rospy.get_param('ekf/v_mat/sig_v_dy')
            sig_v_dz = rospy.get_param('ekf/v_mat/sig_v_dz')
            sig_v_droll = rospy.get_param('ekf/v_mat/sig_v_droll')
            sig_v_dpitch = rospy.get_param('ekf/v_mat/sig_v_dpitch')
            sig_v_dyaw = rospy.get_param('ekf/v_mat/sig_v_dyaw')

            V = np.array(np.diag([sig_v_x ** 2, sig_v_y ** 2, sig_v_z ** 2, sig_v_roll ** 2, sig_v_pitch ** 2, sig_v_yaw ** 2,
                                  sig_v_dx ** 2, sig_v_dy ** 2, sig_v_dz ** 2, sig_v_droll ** 2, sig_v_dpitch ** 2, sig_v_dyaw ** 2]))

            # measurement noise
            sig_w_dist = rospy.get_param('ekf/w_mat/sig_w_dist')
            sig_w_yaw = rospy.get_param('ekf/w_mat/sig_w_yaw')

            W = np.array(np.diag([sig_w_dist ** 2, sig_w_yaw ** 2]))

        except KeyError:
            # if not defined, use distances and yaw measurement
            rospy.logerr("[{}] Some EKF parameter isn't defined correctly".format(
                rospy.get_name()))
            exit(-1)

        return dim_state, dim_meas, W, V, P0, x0


def main():
    global tags, cam_reversed, meas_model_type, process_model_type

    # load apriltag calibration
    try:
        calibration_type = rospy.get_param('~calibration')
    except KeyError:
        rospy.logerr("[{}] ######### You have to set a calibration parameter #########".format(rospy.get_name()))
        exit(-1)

    # load measurement model parameter
    try:
        meas_model_type = rospy.get_param('~measurement_model')
    except KeyError:
        # if not defined, use distances and yaw measurement
        rospy.loginfo("[{}] No measurement model parameter defined, using distances + yaw measurement".format(
            rospy.get_name()))
        meas_model_type = "dist"

    # load process model parameter
    try:
        process_model_type = rospy.get_param('~process_model')
    except KeyError:
        # if not defined, use distances and yaw measurement
        rospy.loginfo("[{}] No process model parameter defined, using XXX".format(
            rospy.get_name()))
        meas_model_type = "standard"

    # load camera reversed parameter
    try:
        cam_reversed = rospy.get_param('~cam_reserved')

    except KeyError:
        # if not defined, camera is not reversed
        cam_reversed = False

    if cam_reversed:
        rospy.loginfo("[{}] Using reversed camera setup".format(rospy.get_name()))

    if calibration_type == "gazebo":
        rospy.loginfo("[{}] Using gazebo calibration".format(rospy.get_name()))
        data_path = rospack.get_path(
            "mu_auv_localization"
        ) + '/scripts/calibration_ground_truth_gazebo.csv'  # in gazebo
    else:
        if calibration_type == "water_tank":
            rospy.loginfo("[{}] Using tank calibration".format(rospy.get_name()))
            data_path = rospack.get_path(
                "mu_auv_localization"
            ) + '/scripts/calibration_tank.csv'  # in real tank
        else:
            rospy.logerr("[{}] ######### Could not find correct parameter for calibration #########".format(
                rospy.get_name()))
            exit(-1)

    tags = genfromtxt(data_path, delimiter=',')  # home PC
    tags = tags[:, 0:4]
    tags[:, 3] += 0.0  # todo WTF warum

    node = EKFNode()
    node.run()


if __name__ == '__main__':
    main()
