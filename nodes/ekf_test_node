#!/usr/bin/env python

import numpy as np
from pyquaternion import Quaternion
import rospy
import rospkg
import tf
from hippocampus_common.node import Node
from mu_auv_localization.ekf_test_class import ExtendedKalmanFilter
from mu_auv_localization.meas_model_class import MeasurementModelDistances
from mu_auv_localization.process_model_class import ProcessModel

from geometry_msgs.msg import PoseStamped, TwistStamped
from apriltag_ros.msg import AprilTagDetectionArray
from sensor_msgs.msg import Imu
from numpy import genfromtxt
import threading

rospack = rospkg.RosPack()


class EKFNode(Node):
    def __init__(self):
        super(EKFNode, self).__init__("ekf_test_node")

        self.calibration_type = rospy.get_param('~calibration', 'gazebo')
        self.meas_model_type = rospy.get_param('~measurement_model', 'dist')
        self.process_model_type = rospy.get_param('~process_model', 'standard')
        self.cam_reversed = rospy.get_param('~cam_reversed', 'False')

        # load apriltag calibration
        if self.calibration_type == "gazebo":
            rospy.loginfo("[{}] Using gazebo calibration".format(rospy.get_name()))
            data_path = rospack.get_path(
                "mu_auv_localization"
            ) + '/scripts/calibration_ground_truth_gazebo.csv'  # in gazebo
        else:
            if self.calibration_type == "water_tank":
                rospy.loginfo("[{}] Using tank calibration".format(rospy.get_name()))
                data_path = rospack.get_path(
                    "mu_auv_localization"
                ) + '/scripts/calibration_tank.csv'  # in real tank
            else:
                rospy.logerr("[{}] ######### Could not find correct parameter for calibration #########".format(
                    rospy.get_name()))
                exit(-1)

        tags = genfromtxt(data_path, delimiter=',')  # home PC
        tags = tags[:, 0:4]
        self.tags = tags

        self.lock = threading.Lock()
        self.t_last_prediction = rospy.get_time()

        if self.meas_model_type == "dist" and self.process_model_type == "standard":
            dim_state, dim_meas, w_mat, v_mat, p0_mat, x0, c_penalty_dist, c_penalty_yaw = self._load_ekf_params_dist()

            process_model = ProcessModel(dim_state, dim_meas, v_mat)
            measurement_model = MeasurementModelDistances(dim_state, dim_meas, w_mat, c_penalty_dist, c_penalty_yaw)
            self.ekf = ExtendedKalmanFilter(dim_state, dim_meas, measurement_model, process_model, x0, p0_mat)
        else:
            rospy.logerr("[{}] Choose valid measurement model.".format(rospy.get_name()))
            exit(-1)

        self.vision_pose_pub = rospy.Publisher("mavros/vision_pose/pose", PoseStamped,
                                               queue_size=1)

        self.estimated_pose_pub = rospy.Publisher('estimated_pose', PoseStamped, queue_size=1)
        self.twist_pub = rospy.Publisher('estimated_twist', TwistStamped, queue_size=1)

        rospy.Subscriber("pose_px4",
                         PoseStamped,
                         self.px4_callback,
                         queue_size=1)

        rospy.Subscriber("mavros/imu/data",
                         Imu,
                         self.imu_callback,
                         queue_size=1)

        rospy.Subscriber("tag_detections",
                         AprilTagDetectionArray,
                         self.apriltag_callback,
                         queue_size=1)

    def apriltag_callback(self, tag_array_msg):
        num_tags = len(tag_array_msg.detections)

        # if tags are detected
        if num_tags:

            if self.meas_model_type == "dist":
                # measurement for each tag consists of distance and yaw angle
                # -> dim_meas = 2
                measurements = np.zeros((num_tags * self.ekf.dim_meas, 1))
                detected_tags = np.zeros((num_tags, 4))

                for i, tag in enumerate(tag_array_msg.detections):
                    tag_id = int(tag.id[0])

                    # add this tag's information to list of detected tags
                    index = np.where(self.tags[:, 0] == tag_id)
                    detected_tags[i, :] = self.tags[index, :]

                    # TODO "calibration"
                    if self.cam_reversed:
                        tag_distance_cam = np.array(
                            ([
                                -tag.pose.pose.pose.position.x * 1.05,
                                -tag.pose.pose.pose.position.y * 1.1,
                                tag.pose.pose.pose.position.z
                            ])
                        )  # Achtung hier ist die 0.1 wegen der kamera position hinzugefuegt
                    else:
                        tag_distance_cam = np.array(
                            ([
                                tag.pose.pose.pose.position.x * 1.05,
                                tag.pose.pose.pose.position.y * 1.1,
                                tag.pose.pose.pose.position.z
                            ])
                        )  # Achtung hier ist die 0.1 wegen der kamera position hinzugefuegt

                    tmpquat = Quaternion(w=tag.pose.pose.pose.orientation.w,
                                         x=tag.pose.pose.pose.orientation.x,
                                         y=tag.pose.pose.pose.orientation.y,
                                         z=tag.pose.pose.pose.orientation.z)

                    yaw_tag_cam = tmpquat.inverse.yaw_pitch_roll[0]

                    if self.cam_reversed:
                        yaw_tag_cam = yaw_tag_cam + np.pi

                    # measurement 1: distance tag - camera
                    measurements[self.ekf.dim_meas * i, 0] = np.linalg.norm(tag_distance_cam)
                    # measurement 2: yaw angle tag - camera (todo check direction)
                    measurements[self.ekf.dim_meas * i + 1, 0] = yaw_tag_cam

            elif self.meas_model_type == "full_pose":

                # not complete yet

                # measurement for each tag consists of full pose measurement camera-tag
                # -> dim_meas = 7
                measurements = np.zeros((num_tags * self.ekf.dim_meas, 1))
                detected_tags = np.zeros((num_tags, 4))

                for i, tag in enumerate(tag_array_msg.detections):

                    tag_id = int(tag.id[0])

                    # add this tag's information to list of detected tags
                    index = np.where(self.tags[:, 0] == tag_id)
                    detected_tags[i, :] = self.tags[index, :]

                    # TODO check "calibration", rewrite this
                    if self.cam_reversed:
                        tag_distance_cam = np.array(
                            ([
                                -tag.pose.pose.pose.position.x * 1.05,
                                -tag.pose.pose.pose.position.y * 1.1,
                                tag.pose.pose.pose.position.z
                            ])
                        )  # Achtung hier ist die 0.1 wegen der kamera position hinzugefuegt
                    else:
                        tag_distance_cam = np.array(
                            ([
                                tag.pose.pose.pose.position.x * 1.05,
                                tag.pose.pose.pose.position.y * 1.1,
                                tag.pose.pose.pose.position.z
                            ])
                        )  # Achtung hier ist die 0.1 wegen der kamera position hinzugefuegt

                    orientation = Quaternion(w=tag.pose.pose.pose.orientation.w,
                                             x=tag.pose.pose.pose.orientation.x,
                                             y=tag.pose.pose.pose.orientation.y,
                                             z=tag.pose.pose.pose.orientation.z)

                    if self.cam_reversed:
                        # todo
                        rospy.logerr("[{}] Orientation for reversed camera not defined yet.".format(rospy.get_name()))

                    # measurement: full pose, orientation not transformed yet!
                    measurements[(self.dim_meas * i):(self.dim_meas*(i + 1) - 1), 0] \
                        = np.array([tag_distance_cam[0], tag_distance_cam[1], tag_distance_cam[2], orientation[3],
                                    tag.pose.pose.pose.orientation.w, tag.pose.pose.pose.orientation.x,
                                    tag.pose.pose.pose.orientation.y, tag.pose.pose.pose.orientation.z]).reshape((-1, 1))

            # do prediction + update step of ekf
            with self.lock:
                now = rospy.get_time()
                self.ekf.predict(now - self.t_last_prediction)
                self.t_last_prediction = now
                self.ekf.update(measurements, detected_tags)

            self._publish_pose_estimation()

    def px4_callback(self, pose_msg):

        measurements = 0
        """
        with self.lock:
            now = rospy.get_time()
            self.ekf.predict(now - self.t_last_prediction)
            self.t_last_prediction = now
            self.ekf.update_orientation(measurements)
        """
        pass

    def imu_callback(self, imu_msg):

        measurements = 0

        """
        with self.lock:
            now = rospy.get_time()
            self.ekf.predict(now - self.t_last_prediction)
            self.t_last_prediction = now
            self.ekf.update_angular_vel(measurements)
        """
        pass

    def _publish_pose_estimation(self):
        estimation = self.ekf.get_x_est()
        position = estimation[:3]
        orientation = estimation[3:7]
        pose = PoseStamped()
        pose.pose.position.x = position[0]
        pose.pose.position.y = position[1]
        pose.pose.position.z = position[2]
        pose.pose.orientation.x = orientation[0]
        pose.pose.orientation.y = orientation[1]
        pose.pose.orientation.z = orientation[2]
        pose.pose.orientation.w = orientation[3]
        pose.header.stamp = rospy.Time.now()
        pose.header.frame_id = "map"
        self.vision_pose_pub.publish(pose)

    def _load_ekf_params_dist(self):

        dim_meas = EKFNode.get_param('~ekf/dim_meas')
        dim_state = EKFNode.get_param('~ekf/dim_state')

        # initial state
        x = self.get_param('~ekf/x0/x')
        y = self.get_param('~ekf/x0/y')
        z = self.get_param('~ekf/x0/z')
        roll = self.get_param('~ekf/x0/roll')
        pitch = self.get_param('~ekf/x0/pitch')
        yaw = self.get_param('~ekf/x0/yaw')
        dx = self.get_param('~ekf/x0/dx')
        dy = self.get_param('~ekf/x0/dy')
        dz = self.get_param('~ekf/x0/dz')
        droll = self.get_param('~ekf/x0/droll')
        dpitch = self.get_param('~ekf/x0/dpitch')
        dyaw = self.get_param('~ekf/x0/dyaw')

        x0 = np.array([x, y, z, roll, pitch, yaw, dx, dy, dz, droll, dpitch, dyaw]).reshape((-1, 1))

        # state covariance P0 params
        sig_x = self.get_param('~ekf/p_mat/sig_x')
        sig_y = self.get_param('~ekf/p_mat/sig_y')
        sig_z = self.get_param('~ekf/p_mat/sig_z')
        sig_roll = self.get_param('~ekf/p_mat/sig_roll')
        sig_pitch = self.get_param('~ekf/p_mat/sig_pitch')
        sig_yaw = self.get_param('~ekf/p_mat/sig_yaw')
        sig_dx = self.get_param('~ekf/p_mat/sig_dx')
        sig_dy = self.get_param('~ekf/p_mat/sig_dy')
        sig_dz = self.get_param('~ekf/p_mat/sig_dz')
        sig_droll = self.get_param('~ekf/p_mat/sig_droll')
        sig_dpitch = self.get_param('~ekf/p_mat/sig_dpitch')
        sig_dyaw = self.get_param('~ekf/p_mat/sig_dyaw')

        p0_mat = np.array(np.diag([sig_x ** 2, sig_y ** 2, sig_z ** 2, sig_roll ** 2, sig_pitch ** 2, sig_yaw ** 2,
                               sig_dx ** 2, sig_dy ** 2, sig_dz ** 2, sig_droll ** 2, sig_dpitch ** 2, sig_dyaw ** 2]))

        # process noise
        sig_v_x = self.get_param('~ekf/v_mat/sig_v_x')
        sig_v_y = self.get_param('~ekf/v_mat/sig_v_y')
        sig_v_z = self.get_param('~ekf/v_mat/sig_v_z')
        sig_v_roll = self.get_param('~ekf/v_mat/sig_v_roll')
        sig_v_pitch = self.get_param('~ekf/v_mat/sig_v_pitch')
        sig_v_yaw = self.get_param('~ekf/v_mat/sig_v_yaw')
        sig_v_dx = self.get_param('~ekf/v_mat/sig_v_dx')
        sig_v_dy = self.get_param('~ekf/v_mat/sig_v_dy')
        sig_v_dz = self.get_param('~ekf/v_mat/sig_v_dz')
        sig_v_droll = self.get_param('~ekf/v_mat/sig_v_droll')
        sig_v_dpitch = self.get_param('~ekf/v_mat/sig_v_dpitch')
        sig_v_dyaw = self.get_param('~ekf/v_mat/sig_v_dyaw')

        v_mat = np.array(np.diag([sig_v_x ** 2, sig_v_y ** 2, sig_v_z ** 2, sig_v_roll ** 2, sig_v_pitch ** 2, sig_v_yaw ** 2,
                              sig_v_dx ** 2, sig_v_dy ** 2, sig_v_dz ** 2, sig_v_droll ** 2, sig_v_dpitch ** 2, sig_v_dyaw ** 2]))

        # measurement noise
        sig_w_dist = self.get_param('~ekf/w_mat/sig_w_dist')
        sig_w_yaw = self.get_param('~ekf/w_mat/sig_w_yaw')

        c_penalty_dist = self.get_param('~ekf/w_mat/c_penalty_dist')
        c_penalty_yaw = self.get_param('~ekf/w_mat/c_penalty_yaw')

        w_mat = np.array(np.diag([sig_w_dist ** 2, sig_w_yaw ** 2]))

        return dim_state, dim_meas, w_mat, v_mat, p0_mat, x0, c_penalty_dist, c_penalty_yaw


def main():
    node = EKFNode()
    node.run()


if __name__ == '__main__':
    main()
